// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'duration_type.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$DurationTypeTearOff {
  const _$DurationTypeTearOff();

  _Today today() {
    return const _Today();
  }

  _Week week() {
    return const _Week();
  }

  _Month month() {
    return const _Month();
  }

  _Year year() {
    return const _Year();
  }
}

/// @nodoc
const $DurationType = _$DurationTypeTearOff();

/// @nodoc
mixin _$DurationType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() today,
    required TResult Function() week,
    required TResult Function() month,
    required TResult Function() year,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? today,
    TResult Function()? week,
    TResult Function()? month,
    TResult Function()? year,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? today,
    TResult Function()? week,
    TResult Function()? month,
    TResult Function()? year,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Today value) today,
    required TResult Function(_Week value) week,
    required TResult Function(_Month value) month,
    required TResult Function(_Year value) year,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Today value)? today,
    TResult Function(_Week value)? week,
    TResult Function(_Month value)? month,
    TResult Function(_Year value)? year,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Today value)? today,
    TResult Function(_Week value)? week,
    TResult Function(_Month value)? month,
    TResult Function(_Year value)? year,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DurationTypeCopyWith<$Res> {
  factory $DurationTypeCopyWith(
          DurationType value, $Res Function(DurationType) then) =
      _$DurationTypeCopyWithImpl<$Res>;
}

/// @nodoc
class _$DurationTypeCopyWithImpl<$Res> implements $DurationTypeCopyWith<$Res> {
  _$DurationTypeCopyWithImpl(this._value, this._then);

  final DurationType _value;
  // ignore: unused_field
  final $Res Function(DurationType) _then;
}

/// @nodoc
abstract class _$TodayCopyWith<$Res> {
  factory _$TodayCopyWith(_Today value, $Res Function(_Today) then) =
      __$TodayCopyWithImpl<$Res>;
}

/// @nodoc
class __$TodayCopyWithImpl<$Res> extends _$DurationTypeCopyWithImpl<$Res>
    implements _$TodayCopyWith<$Res> {
  __$TodayCopyWithImpl(_Today _value, $Res Function(_Today) _then)
      : super(_value, (v) => _then(v as _Today));

  @override
  _Today get _value => super._value as _Today;
}

/// @nodoc

class _$_Today implements _Today {
  const _$_Today();

  @override
  String toString() {
    return 'DurationType.today()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Today);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() today,
    required TResult Function() week,
    required TResult Function() month,
    required TResult Function() year,
  }) {
    return today();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? today,
    TResult Function()? week,
    TResult Function()? month,
    TResult Function()? year,
  }) {
    return today?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? today,
    TResult Function()? week,
    TResult Function()? month,
    TResult Function()? year,
    required TResult orElse(),
  }) {
    if (today != null) {
      return today();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Today value) today,
    required TResult Function(_Week value) week,
    required TResult Function(_Month value) month,
    required TResult Function(_Year value) year,
  }) {
    return today(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Today value)? today,
    TResult Function(_Week value)? week,
    TResult Function(_Month value)? month,
    TResult Function(_Year value)? year,
  }) {
    return today?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Today value)? today,
    TResult Function(_Week value)? week,
    TResult Function(_Month value)? month,
    TResult Function(_Year value)? year,
    required TResult orElse(),
  }) {
    if (today != null) {
      return today(this);
    }
    return orElse();
  }
}

abstract class _Today implements DurationType {
  const factory _Today() = _$_Today;
}

/// @nodoc
abstract class _$WeekCopyWith<$Res> {
  factory _$WeekCopyWith(_Week value, $Res Function(_Week) then) =
      __$WeekCopyWithImpl<$Res>;
}

/// @nodoc
class __$WeekCopyWithImpl<$Res> extends _$DurationTypeCopyWithImpl<$Res>
    implements _$WeekCopyWith<$Res> {
  __$WeekCopyWithImpl(_Week _value, $Res Function(_Week) _then)
      : super(_value, (v) => _then(v as _Week));

  @override
  _Week get _value => super._value as _Week;
}

/// @nodoc

class _$_Week implements _Week {
  const _$_Week();

  @override
  String toString() {
    return 'DurationType.week()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Week);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() today,
    required TResult Function() week,
    required TResult Function() month,
    required TResult Function() year,
  }) {
    return week();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? today,
    TResult Function()? week,
    TResult Function()? month,
    TResult Function()? year,
  }) {
    return week?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? today,
    TResult Function()? week,
    TResult Function()? month,
    TResult Function()? year,
    required TResult orElse(),
  }) {
    if (week != null) {
      return week();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Today value) today,
    required TResult Function(_Week value) week,
    required TResult Function(_Month value) month,
    required TResult Function(_Year value) year,
  }) {
    return week(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Today value)? today,
    TResult Function(_Week value)? week,
    TResult Function(_Month value)? month,
    TResult Function(_Year value)? year,
  }) {
    return week?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Today value)? today,
    TResult Function(_Week value)? week,
    TResult Function(_Month value)? month,
    TResult Function(_Year value)? year,
    required TResult orElse(),
  }) {
    if (week != null) {
      return week(this);
    }
    return orElse();
  }
}

abstract class _Week implements DurationType {
  const factory _Week() = _$_Week;
}

/// @nodoc
abstract class _$MonthCopyWith<$Res> {
  factory _$MonthCopyWith(_Month value, $Res Function(_Month) then) =
      __$MonthCopyWithImpl<$Res>;
}

/// @nodoc
class __$MonthCopyWithImpl<$Res> extends _$DurationTypeCopyWithImpl<$Res>
    implements _$MonthCopyWith<$Res> {
  __$MonthCopyWithImpl(_Month _value, $Res Function(_Month) _then)
      : super(_value, (v) => _then(v as _Month));

  @override
  _Month get _value => super._value as _Month;
}

/// @nodoc

class _$_Month implements _Month {
  const _$_Month();

  @override
  String toString() {
    return 'DurationType.month()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Month);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() today,
    required TResult Function() week,
    required TResult Function() month,
    required TResult Function() year,
  }) {
    return month();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? today,
    TResult Function()? week,
    TResult Function()? month,
    TResult Function()? year,
  }) {
    return month?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? today,
    TResult Function()? week,
    TResult Function()? month,
    TResult Function()? year,
    required TResult orElse(),
  }) {
    if (month != null) {
      return month();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Today value) today,
    required TResult Function(_Week value) week,
    required TResult Function(_Month value) month,
    required TResult Function(_Year value) year,
  }) {
    return month(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Today value)? today,
    TResult Function(_Week value)? week,
    TResult Function(_Month value)? month,
    TResult Function(_Year value)? year,
  }) {
    return month?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Today value)? today,
    TResult Function(_Week value)? week,
    TResult Function(_Month value)? month,
    TResult Function(_Year value)? year,
    required TResult orElse(),
  }) {
    if (month != null) {
      return month(this);
    }
    return orElse();
  }
}

abstract class _Month implements DurationType {
  const factory _Month() = _$_Month;
}

/// @nodoc
abstract class _$YearCopyWith<$Res> {
  factory _$YearCopyWith(_Year value, $Res Function(_Year) then) =
      __$YearCopyWithImpl<$Res>;
}

/// @nodoc
class __$YearCopyWithImpl<$Res> extends _$DurationTypeCopyWithImpl<$Res>
    implements _$YearCopyWith<$Res> {
  __$YearCopyWithImpl(_Year _value, $Res Function(_Year) _then)
      : super(_value, (v) => _then(v as _Year));

  @override
  _Year get _value => super._value as _Year;
}

/// @nodoc

class _$_Year implements _Year {
  const _$_Year();

  @override
  String toString() {
    return 'DurationType.year()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Year);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() today,
    required TResult Function() week,
    required TResult Function() month,
    required TResult Function() year,
  }) {
    return year();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? today,
    TResult Function()? week,
    TResult Function()? month,
    TResult Function()? year,
  }) {
    return year?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? today,
    TResult Function()? week,
    TResult Function()? month,
    TResult Function()? year,
    required TResult orElse(),
  }) {
    if (year != null) {
      return year();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Today value) today,
    required TResult Function(_Week value) week,
    required TResult Function(_Month value) month,
    required TResult Function(_Year value) year,
  }) {
    return year(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Today value)? today,
    TResult Function(_Week value)? week,
    TResult Function(_Month value)? month,
    TResult Function(_Year value)? year,
  }) {
    return year?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Today value)? today,
    TResult Function(_Week value)? week,
    TResult Function(_Month value)? month,
    TResult Function(_Year value)? year,
    required TResult orElse(),
  }) {
    if (year != null) {
      return year(this);
    }
    return orElse();
  }
}

abstract class _Year implements DurationType {
  const factory _Year() = _$_Year;
}
